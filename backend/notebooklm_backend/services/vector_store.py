from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable

import chromadb
from chromadb import Collection

from ..config import AppConfig
from .chunking import TextChunk
from .embeddings import EmbeddingBackend
from .document_summary import DocumentSummary


@dataclass
class VectorStoreManager:
    client: chromadb.PersistentClient
    embedding_backend: EmbeddingBackend

    def _collection_name(self, notebook_id: str) -> str:
        return f"notebook_{notebook_id}"

    def get_collection(self, notebook_id: str) -> Collection:
        return self.client.get_or_create_collection(name=self._collection_name(notebook_id))

    def add_chunks(self, notebook_id: str, chunks: Iterable[TextChunk]) -> int:
        chunk_list = list(chunks)
        if not chunk_list:
            return 0

        documents = [chunk.text for chunk in chunk_list]
        embeddings = self.embedding_backend.embed(documents)
        metadatas = [
            {
                "source_path": chunk.source_path,
                "order": chunk.order,
            }
            for chunk in chunk_list
        ]
        ids = [chunk.chunk_id for chunk in chunk_list]

        collection = self.get_collection(notebook_id)
        collection.add(
            ids=ids,
            documents=documents,
            metadatas=metadatas,
            embeddings=embeddings,
        )
        return len(chunk_list)

    def query(
        self,
        notebook_id: str,
        query: str,
        top_k: int = 5,
        where: dict | None = None,
    ) -> dict:
        """
        Query the collection using embeddings generated by our configured backend.
        Avoid relying on Chroma's built-in embedder (which may use a different dimension).
        """
        collection = self.get_collection(notebook_id)
        query_emb = self.embedding_backend.embed([query])
        query_kwargs = {
            "query_embeddings": query_emb,
            "n_results": top_k,
        }
        if where:
            try:
                query_kwargs["where"] = where
                return collection.query(**query_kwargs)
            except Exception:
                # Fallback to unfiltered query if the where syntax is unsupported
                pass
        return collection.query(**query_kwargs)
    
    def _doc_summaries_collection_name(self, notebook_id: str) -> str:
        """Get the name of the document summaries collection."""
        return f"notebook_{notebook_id}_summaries"
    
    def store_document_summary(self, notebook_id: str, summary: DocumentSummary) -> None:
        """
        Store a document summary in a separate collection for fast document-level filtering.
        """
        summaries_collection = self.client.get_or_create_collection(
            name=self._doc_summaries_collection_name(notebook_id)
        )
        
        # Embed the summary for similarity search
        summary_embedding = self.embedding_backend.embed([summary.summary])

        # Store summary with metadata
        import hashlib
        # Use a stable, notebook-scoped summary id to avoid collisions/overwrites
        sid_input = f"{notebook_id}:{summary.source_path}:{summary.chunk_count}:{summary.summary[:64]}"
        sid = hashlib.md5(sid_input.encode()).hexdigest()
        summaries_collection.add(
            ids=[sid],
            documents=[summary.summary],
            metadatas=[{
                "source_path": summary.source_path,
                "chunk_count": summary.chunk_count,
                "document_type": summary.document_type or "unknown",
            }],
            embeddings=summary_embedding,
        )
    
    def query_document_summaries(
        self,
        notebook_id: str,
        query: str,
        top_k: int = 3,
    ) -> list[DocumentSummary]:
        """
        Query document summaries to find relevant documents (Stage 1: Coarse filtering).
        Returns summaries of documents that match the query.
        """
        try:
            summaries_collection = self.client.get_collection(
                name=self._doc_summaries_collection_name(notebook_id)
            )
        except Exception:
            # No summaries collection yet, return empty
            return []
        
        # Embed query and search summaries
        query_emb = self.embedding_backend.embed([query])
        results = summaries_collection.query(query_embeddings=query_emb, n_results=top_k)
        
        # Convert to DocumentSummary objects
        summaries = []
        documents = results.get("documents", [[]])[0]
        metadatas = results.get("metadatas", [[]])[0]
        
        for doc, meta in zip(documents, metadatas):
            if isinstance(meta, dict):
                summaries.append(DocumentSummary(
                    source_path=meta.get("source_path", "unknown"),
                    summary=doc,
                    chunk_count=meta.get("chunk_count", 0),
                    document_type=meta.get("document_type"),
                ))
        
        return summaries
    
    def get_all_document_summaries(self, notebook_id: str) -> list[DocumentSummary]:
        """Get all document summaries for a notebook."""
        try:
            summaries_collection = self.client.get_collection(
                name=self._doc_summaries_collection_name(notebook_id)
            )
        except Exception:
            return []
        
        all_docs = summaries_collection.get(include=["documents", "metadatas"])
        documents = all_docs.get("documents", [])
        metadatas = all_docs.get("metadatas", [])
        
        summaries = []
        for doc, meta in zip(documents, metadatas):
            if isinstance(meta, dict):
                summaries.append(DocumentSummary(
                    source_path=meta.get("source_path", "unknown"),
                    summary=doc,
                    chunk_count=meta.get("chunk_count", 0),
                    document_type=meta.get("document_type"),
                ))
        
        return summaries


def create_vector_store(settings: AppConfig, embedding_backend: EmbeddingBackend) -> VectorStoreManager:
    client = chromadb.PersistentClient(path=str(settings.index_dir))
    return VectorStoreManager(client=client, embedding_backend=embedding_backend)
